//
// Created by Yuanqi on 12/26/16.
//

#ifndef PBR_INTERACTION_H
#define PBR_INTERACTION_H


class Interaction {

public:

    // All interactions must have a point and time associated with them.

    Point3f p;
    Float   time;

    // For interactions where point p was computed by ray interaction, some floating point error is generally present
    // in the p value. pError gives a conservative bound on this error.

    Vector3f pError;

    Vector3f wo;

    // For interactions on surfaces, n stores the surface normal at the point.

    Normal3f n;

    // The scattering media at the intersection point.

    MediumInterface mediumInterface;


    // The most general constructor.

    Interaction(
            const Point3f &p,
            const Normal3f &n,
            const Vector3f &pError,
            const Vector3f &wo,
            Float time,
            const MediumInterface &mediumInterface
    ) : p(p),
        time(time),
        pError(pError),
        wo(wo),
        n(n),
        mediumInterface(mediumInterface)
    {
    }

    bool IsSurfaceInteraction() const {
        return n != Normal3f();
    }
};

/**
 * The geometry of particular point on a surface is represented by a SurfaceInteraction, which supplies enough
 * information about the surface point to allow shading and geoemtric operations in the rest of pbr to be implemented
 * generically.
 */

class SurfaceInteraction : public Interaction {

public:

    // In addition to the point p and surface normal n from the base class, it also stores (u,v) coordinates from the
    // parametrization of the surface and the parametric partial derivatives of the point dp/du and dp/dv. It's also
    // useful to have a pointer to the Shape that point lies on as well as the partial derivatives of the surface
    // normal.

    Point2f uv;
    Vector3f dpdu, dpdv;
    Normal3f dndu, dndv;
    const Shape *shape = nullptr;

    // SurfaceInteraction stores a second instance of a surface normal and the various partial derivatives to represent
    // possibly perturbed values of these quantities as can be generated by bump mapping or interpolated per-vertex
    // normals with triangles. Some parts of the system use this shading geometry, with others need to work with the
    // original quantities.

    struct {
        Normal3f n;
        Vector3f dpdu, dpdv;
        Normal3f dndu, dndv;
    } shading;

    SurfaceInteraction(
            const Point3f &p,
            const Vector3f &pError,
            const Point2f &uv,
            const Vector3f &wo,
            const Vector3f &dpdu,
            const Vector3f &dpdv,
            const Normal3f &dndu,
            const Normal3f &dndv,
            Float time,
            const Shape *shape
    ) : Interaction(p, Normal3f(Normalize(Cross(dpdu, dpdv))), pError, wo, time, nullptr),
        uv(uv),
        dpdu(dpdu),
        dpdv(dpdv),
        dndu(dndu),
        dndv(dndv),
        shape(shape)
    {

        // The shading geometry values are initialized in the constructor to match the original surface geometry.

        shading.n = n;
        shading.dpdu = dpdu;
        shading.dpdv = dpdv;
        shading.dndu = dndu;
        shading.dndv = dndv;

        // The surface normal in pbr assumes that for closed shapes it points to the outside of the shape. For geometry
        // used as an area light source, light is emitted from only the side of the surface that the normal points
        // toward; the other side is dark.

        if (shape && (shape->reverseOrientation ^ shape->transformSwapsHandedness)) {
            n *= -1;
            shading.n *= -1;
        }

    }

    // When a shading coordinate frame is computed, the SurfaceInteraction is updated via this method.

    void SetShadingGeometry(
            const Vector3f &dpdus,
            const Vector3f &dpdvs,
            const Normal3f &dndus,
            const Normal3f &dndvs,
            bool orientationIsAuthoritative
    ) {

        // Compute shading.n for SurfaceInteraction.

        shading.n = Normalize((Normal3f)Cross(dpdus, dpdvs));
        if (shape && (shape->reverseOrientation ^ shape->transformSwapsHandedness))
            shading.n *= -1;
        if (orientationIsAuthoritative)
            n = Faceforward(n, shading.n);
        else
            shading.n = Faceforward(shading.n, n);

        // Initialize shading partial derivative values.

        shading.dpdu = dpdus;
        shading.dpdv = dpdvs;
        shading.dndu = dndus;
        shading.dndv = dndvs;
    }
};











#endif //PBR_INTERACTION_H
